#include "Mesh-Loader.h"

int ct_mesh_load(ct_mesh_t *mesh, char error_message[NM_MAX_ERROR_LENGTH])
{
	// Get extension:
	char extension[NM_MAX_PATH_LENGTH];
	int current_position = strlen(mesh->path) - 1;
	while (1)
	{
		if (mesh->path[current_position] == '.') { break; }
		if (current_position == 0)
		{
			snprintf(error_message, NM_MAX_ERROR_LENGTH,
				"File has no extension for mesh \"%s\".", mesh->name);
			return -1;
		}
		current_position--;
	}
	strcpy(extension, &(mesh->path[current_position]));
	current_position = 0;
	while (extension[current_position] != '\0')
	{
		extension[current_position] = tolower(extension[current_position]);
		current_position++;
	}

	if (!strcmp(extension, ".obj"))
	{
		if (ct_mesh_load_obj(mesh, error_message)) { return -1; }
	}
	else if (!strcmp(extension, ".txt"))
	{
		if (ct_mesh_load_voxels(mesh, error_message)) { return -1; }
	}
	else
	{
		snprintf(error_message, NM_MAX_ERROR_LENGTH,
			"File extension \"%s\" not recognised for mesh \"%s\".",
			extension, mesh->name);
		return -1;
	}

	if (ct_mesh_calculate_edges(mesh, error_message)) { return -1; }
	if (ct_mesh_check_manifold(mesh, error_message)) { return -1; }

	return 0;
}

/**************
 * OBJ meshes *
 **************/

int ct_mesh_load_obj(ct_mesh_t *mesh, char error_message[NM_MAX_ERROR_LENGTH])
{
	tinyobj_attrib_t attrib;
	tinyobj_shape_t *shapes = NULL;
	size_t num_shapes;
	tinyobj_material_t *materials = NULL;
	size_t num_materials;

	if (tinyobj_parse_obj(&attrib, &shapes, &num_shapes, &materials, &num_materials,
		mesh->path, tinyobj_file_reader_callback, NULL, TINYOBJ_FLAG_TRIANGULATE)
		!= TINYOBJ_SUCCESS)
	{
		snprintf(error_message, NM_MAX_ERROR_LENGTH,
			"Could not parse file \"%s\" with TinyOBJLoader-C.", mesh->path);
		return -1;
	}

	if ((attrib.num_vertices) > UINT32_MAX)
	{
		snprintf(error_message, NM_MAX_ERROR_LENGTH,
			"Mesh \"%s\" is too large.", mesh->name);
		tinyobj_free(&attrib, num_shapes, shapes, num_materials, materials);
		return -1;
	}

	mesh->num_vertices = attrib.num_vertices;
	mesh->num_normals = attrib.num_normals;
	mesh->num_colours = attrib.num_normals; // TinyOBJC doesn't use colours, so use normals.
	mesh->num_uv_coordinates = attrib.num_texcoords;
	mesh->num_edges = attrib.num_face_num_verts * 3;
	for (int i = 0; i < NM_MAX_LOD_LEVELS; i++)
	{
		mesh->num_faces[i] = attrib.num_face_num_verts;
	}

	if (!mesh->num_vertices || !mesh->num_faces[0])
	{
		snprintf(error_message, NM_MAX_ERROR_LENGTH,
			"Mesh \"%s\" has no vertices/faces.", mesh->name);
		tinyobj_free(&attrib, num_shapes, shapes, num_materials, materials);
		return -1;
	}

	// If any array is empty, fill it with a single element:
	if (!mesh->num_normals) { mesh->num_normals = 1; }
	if (!mesh->num_colours) { mesh->num_colours = 1; }
	if (!mesh->num_uv_coordinates) { mesh->num_uv_coordinates = 1; }

	if (ct_mesh_allocate(mesh, error_message))
	{
		snprintf(error_message, NM_MAX_ERROR_LENGTH,
			"Could not allocate memory for mesh \"%s\".", mesh->name);
		tinyobj_free(&attrib, num_shapes, shapes, num_materials, materials);
		return -1;
	}

	for (unsigned int i = 0; i < attrib.num_vertices; i++)
	{
		mesh->vertices[i].x = attrib.vertices[i * 3];
		mesh->vertices[i].y = attrib.vertices[(i * 3) + 1];
		mesh->vertices[i].z = attrib.vertices[(i * 3) + 2];
	}

	for (unsigned int i = 0; i < attrib.num_normals; i++)
	{
		mesh->normals[i].x = attrib.normals[i * 3] * 127.5;
		mesh->normals[i].y = attrib.normals[(i * 3) + 1] * 127.5;
		mesh->normals[i].z = attrib.normals[(i * 3) + 2] * 127.5;

		mesh->colours[i].r = attrib.normals[i * 3] * 255;
		mesh->colours[i].g = attrib.normals[(i * 3) + 1] * 255;
		mesh->colours[i].b = attrib.normals[(i * 3) + 2] * 255;
		mesh->colours[i].a = 255;
	}

	for (unsigned int i = 0; i < attrib.num_texcoords; i++)
	{
		mesh->uv_coordinates[i].u = attrib.texcoords[i * 2];
		mesh->uv_coordinates[i].v = attrib.texcoords[(i * 2) + 1];
	}

	for (unsigned int i = 0; i < attrib.num_face_num_verts; i++)
	{
		for (int j = 0; j < 3; j++)
		{
			mesh->faces[0][i].p[j] = attrib.faces[(i * 3) + j].v_idx;
			mesh->faces[0][i].n[j] = 0;
			mesh->faces[0][i].c[j] = 0;
			mesh->faces[0][i].u[j] = 0;
			if (attrib.num_normals > 0)
			{
				mesh->faces[0][i].n[j] = attrib.faces[(i * 3) + j].vn_idx;
				mesh->faces[0][i].c[j] = attrib.faces[(i * 3) + j].vn_idx;
			}
			if (attrib.num_texcoords > 0)
			{
				mesh->faces[0][i].u[j] = attrib.faces[(i * 3) + j].vt_idx;
			}
		}
	}

	tinyobj_free(&attrib, num_shapes, shapes, num_materials, materials);
	return 0;
}

int ct_mesh_write_obj(FILE *file, ct_mesh_t *mesh, char error_message[NM_MAX_ERROR_LENGTH])
{
	if (ct_mesh_check_validity(mesh, error_message)) { return -1; }

	fprintf(file, "#\n# Generated by https://github.com/Nell-Mills/Mesh-Processing\n");
	fprintf(file, "# (For testing purposes)\n#\n");

	for (uint32_t i = 0; i < mesh->num_vertices; i++)
	{
		fprintf(file, "v %f %f %f\n", mesh->vertices[i].x,
			mesh->vertices[i].y, mesh->vertices[i].z);
	}

	for (uint32_t i = 0; i < mesh->num_normals; i++)
	{
		fprintf(file, "vn %f %f %f\n", (mesh->normals[i].x * 1.f) / 127.5f,
						(mesh->normals[i].y * 1.f) / 127.5f,
						(mesh->normals[i].z * 1.f) / 127.5f);
	}

	for (uint32_t i = 0; i < mesh->num_uv_coordinates; i++)
	{
		fprintf(file, "vt %f %f\n", mesh->uv_coordinates[i].u, mesh->uv_coordinates[i].v);
	}

	for (uint32_t i = 0; i < mesh->num_faces[0]; i++)
	{
		fprintf(file, "f");
		for (int j = 0; j < 3; j++)
		{
			fprintf(file, " %u/%u/%u", mesh->faces[0][i].p[j] + 1,
				mesh->faces[0][i].u[j] + 1, mesh->faces[0][i].n[j] + 1);
		}
		fprintf(file, "\n");
	}

	return 0;
}

void tinyobj_file_reader_callback(void *ctx, const char *filename, const int is_mtl,
				const char *obj_filename, char **data, size_t *len)
{
	*data = SDL_LoadFile(filename, len);
}

void tinyobj_free(tinyobj_attrib_t *attrib, size_t num_shapes, tinyobj_shape_t *shapes,
				size_t num_materials, tinyobj_material_t *materials)
{
	tinyobj_attrib_free(attrib);
	tinyobj_shapes_free(shapes, num_shapes);
	tinyobj_materials_free(materials, num_materials);
}

/****************
 * Voxel meshes *
 ****************/

int ct_mesh_load_voxels(ct_mesh_t *mesh, char error_message[NM_MAX_ERROR_LENGTH])
{
	/* Loading 3D data of the following format (making strict assumptions):
	 * X Y Z
	 * f . f
	 * . . .
	 * f . f
	 *
	 * f . f
	 * . . .
	 * f . f
	 *
	 * Where X Y and Z are the number of voxels in each dimension, and are
	 * followed by the data in matrix form (Z slices, 1 float per voxel). */

	FILE *file = fopen(mesh->path, "r");
	if (!file)
	{
		snprintf(error_message, NM_MAX_ERROR_LENGTH,
			"Could not open file \"%s\" for mesh \"%s\".", mesh->path, mesh->name);
		return -1;
	}

	fseek(file, 0, SEEK_END);
	long data_size = ftell(file);
	rewind(file);

	char *data = malloc(data_size + 1);
	if (!data)
	{
		snprintf(error_message, NM_MAX_ERROR_LENGTH,
			"Could not allocate data buffer memory for mesh \"%s\".", mesh->name);
		fclose(file);
		return -1;
	}
	fread(data, data_size, 1, file);
	fclose(file);

	char *position = data;
	char *end = data + data_size;

	// Parse voxel dimensions:
	uint32_t dimensions[3] = { 0, 0, 0 };
	for (int i = 0; i < 3; i++)
	{
		while ((position < end) && isspace(*position)) { position++; }
		while ((position < end) && (*position >= '0') && (*position <= '9'))
		{
			dimensions[i] = (dimensions[i] * 10) + (*position - '0');
			position++;
		}
	}

	if (!dimensions[0] || !dimensions[1] || !dimensions[2])
	{
		snprintf(error_message, NM_MAX_ERROR_LENGTH,
			"Voxel X, Y or Z dimension is 0 for mesh \"%s\".", mesh->name);
		free(data);
		return -1;
	}

	// Parse voxel data:
	uint32_t num_voxels = dimensions[0] * dimensions[1] * dimensions[2];
	float *voxels = malloc(num_voxels * sizeof(float));
	if (!voxels)
	{
		snprintf(error_message, NM_MAX_ERROR_LENGTH,
			"Could not allocate voxel memory for mesh \"%s\".", mesh->name);
		free(data);
		return -1;
	}
	memset(voxels, 0, num_voxels * sizeof(float));

	for (uint32_t i = 0; i < num_voxels; i++)
	{
		if (position == end)
		{
			// Prematurely ran out of values:
			snprintf(error_message, NM_MAX_ERROR_LENGTH,
				"Not enough voxel values in file for mesh \"%s\".\n", mesh->name);
			free(data);
			free(voxels);
			return -1;
		}

		float negative = 1.f;
		while ((position < end) && isspace(*position)) { position++; }
		if ((position < end) && (*position == '-'))
		{
			negative = -1.f;
		}
		while ((position < end) && (*position >= '0') && (*position <= '9'))
		{
			voxels[i] = (voxels[i] * 10.f) + ((*position - '0') * 1.f);
			position++;
		}
		if ((position < end) && (*position == '.'))
		{
			position++;
			float decimal = 0.f;
			float multiplier = 1.f;
			while((position < end) && (*position >= '0') && (*position <= '9'))
			{
				decimal = (decimal * 10.f) + ((*position - '0') * 1.f);
				multiplier *= 10.f;
				position++;
			}
			voxels[i] += decimal / multiplier;
		}
		voxels[i] *= negative;
	}

	free(data);
	free(voxels);
	return 0;
}

uint32_t ct_get_voxel_index(uint32_t coordinates[3], uint32_t dimensions[3])
{
	// X, Y, Z = column, row, slice.
	return ((dimensions[0] * dimensions[1] * coordinates[2]) +
		(dimensions[0] * coordinates[1]) + coordinates[0]);
}

#ifdef CT_DEBUG
void ct_voxels_print(FILE *file, uint32_t dimensions[3], float *voxels)
{
	fprintf(file, "********************\n");
	fprintf(file, "* Voxel debug info *\n");
	fprintf(file, "********************\n\n");

	fprintf(file, "Dimensions --> X: %u, Y: %u, Z: %u\n",
		dimensions[0], dimensions[1], dimensions[2]);

	uint32_t coordinates[3] = { 0, 0, 0 };
	uint32_t index;
	for (uint32_t z = 0; z < dimensions[2]; z++)
	{
		fprintf(file, "\n");
		for (uint32_t y = 0; y < dimensions[1]; y++)
		{
			index = ct_get_voxel_index(coordinates, dimensions);
			fprintf(file, "%.3f", voxels[index]);
			coordinates[0]++;
			for (uint32_t x = 1; x < dimensions[0]; x++)
			{
				index = ct_get_voxel_index(coordinates, dimensions);
				fprintf(file, "\t%.3f", voxels[index]);
				coordinates[0]++;
			}
			fprintf(file, "\n");
			coordinates[1]++;
			coordinates[0] = 0;
		}
		coordinates[2]++;
		coordinates[1] = 0;
	}
}
#endif
